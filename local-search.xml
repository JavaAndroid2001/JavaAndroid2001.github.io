<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>今晚加了两个社团</title>
    <link href="/2020/12/02/%E4%BB%8A%E6%99%9A%E5%8A%A0%E4%BA%86%E4%B8%A4%E4%B8%AA%E7%A4%BE%E5%9B%A2/"/>
    <url>/2020/12/02/%E4%BB%8A%E6%99%9A%E5%8A%A0%E4%BA%86%E4%B8%A4%E4%B8%AA%E7%A4%BE%E5%9B%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="今晚加了两个社团"><a href="#今晚加了两个社团" class="headerlink" title="今晚加了两个社团"></a>今晚加了两个社团</h2><hr><p>分别是杠精社和音乐社！！！</p><p>所以！！今晚没时间学习新知识！！！！</p><p>现在是北京时间晚上22：21，要睡觉觉啦！！！</p><p>good night！！</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象的三大特征——继承2</title>
    <link href="/2020/12/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF2/"/>
    <url>/2020/12/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF2/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象的三大特征：封装，继承，多态。"><a href="#面向对象的三大特征：封装，继承，多态。" class="headerlink" title="面向对象的三大特征：封装，继承，多态。"></a>面向对象的三大特征：封装，继承，多态。</h2><hr><h2 id="继承-2"><a href="#继承-2" class="headerlink" title="继承 2"></a>继承 2</h2><hr><h5 id="继承变量范围："><a href="#继承变量范围：" class="headerlink" title="继承变量范围："></a>继承变量范围：</h5><ul><li>关于继承变量范围的使用<br></br>&emsp;&emsp;<br>局部变量：           直接写成员变量名<br></br>&emsp;&emsp;<br>本类的成员变量：      this.成员变量名<br></br>&emsp;&emsp;<br>父类的成员变量：      super.成员变量名</li></ul><ul><li>代码示例部分<pre><code class="hljs javascpit">    int num &#x3D; 10;    public void method()&#123;        int num &#x3D; 30;        System.out.println(num);    &#x2F;&#x2F;30        &#x2F;&#x2F;局部变量        System.out.println(this.num);   &#x2F;&#x2F;10          &#x2F;&#x2F;本类的成员变量        System.out.println(super.num);  &#x2F;&#x2F;20        &#x2F;&#x2F;父类的成员变量    &#125;&#125;</code></pre></li></ul><h5 id="Override："><a href="#Override：" class="headerlink" title="Override："></a>Override：</h5></br>重写（Override）</br>概念：在继承关系当中，方法的名称一样，参数列表也一样</br>重写（Override）：方法的名称一样，参数列表【也一样】。覆盖、覆写。</br>重载（Override）：方法的名称一样，参数列表【不一样】。</br></br>方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。</br></br><p>注意事项：<br></br></p><ul><li>1.必须保证父子类之间方法的名称相同，参数列表也相同 。<br></br>&emsp;&emsp;<br>@Override：写在方法前面，用来检测是不是有效的正确覆盖重写。<br></br>&emsp;&emsp;<br>这个注释就算不写，只要满足要求，也是正确的方法覆盖重写。<br></br></br></li></ul><ul><li>2.子类方法的返回值必须【小于等于】父类方法的返回值范围。<br></br>&emsp;&emsp;<br>前提：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类</br></li></ul><ul><li>3.子类方法的权限必须【大于等于】父类方法的权限修饰符。<br></br>&emsp;&emsp;<br>小扩展提示：public &gt; protected &gt; (default) &gt; private<br></br>&emsp;&emsp;<br>备注：（default）不是关键字default，而是什么都不写，留空。</br></li></ul><p></br></br></br></br></br></p><ul><li>扩展Object(祖宗类)</li></ul><p>扩展：  </br><br>void<br></br><br>学过Java的人都知道void的意思是空<br></br><br>如果你去问老手，老手会告诉你说：“void什么都不是，你只要记住void就是空，在方法申明的时候表示该方法没有返回值”。<br></br></p><ul><li>扩展代码示例部分<pre><code class="hljs javascpit">public Object method()&#123;      return null;      &#x2F;&#x2F;用了可实例化的类就必须要拥有返回值，不然报错  &#125;</code></pre></li></ul><ul><li>子类区</br>@Override写在方法前面，用来检测是不是有效的正确覆盖重写。</br></br>子类方法的返回值必须【小于等于】父类方法的返回值范围。</br>前提：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类</li></ul><ul><li>子类代码示例部分</li></ul><pre><code class="hljs javascpit">public class Zi extends Fu &#123;    @Override       &#x2F;&#x2F; 写在方法前面，用来检测是不是有效的正确覆盖重写。    public Object method()&#123;        &#x2F;&#x2F;若这里使用void则不符合继承规则子类高于父类        &#x2F;&#x2F;不能高于父类的返回值类型，但是可以等于        return null;    &#125;&#125;</code></pre><hr><p>最后说一下继承的应用场景<br></br></br><br>根据设计原则：<br></br><br>对于已经投入使用的类，尽量不要进行修改。<br></br><br>推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容。</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象的三大特征——继承</title>
    <link href="/2020/11/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85/"/>
    <url>/2020/11/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E2%80%94%E2%80%94%E5%B0%81%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="面向对象的三大特征：封装，继承，多态。"><a href="#面向对象的三大特征：封装，继承，多态。" class="headerlink" title="面向对象的三大特征：封装，继承，多态。"></a>面向对象的三大特征：封装，继承，多态。</h2><hr><h2 id="继承-1"><a href="#继承-1" class="headerlink" title="继承 1"></a>继承 1</h2><hr><h5 id="记事本笔记："><a href="#记事本笔记：" class="headerlink" title="记事本笔记："></a>记事本笔记：</h5> </br>继承是多态的前提，如果没有继承，就没有多态。 </br><p>继承主要解决的问题就是： 共性抽取。<br> </br><br>继承关系当中的特点：<br> </br>&emsp;&emsp;<br>    1.子类可以拥有父类的“内容”<br>     </br>&emsp;&emsp;<br>    2.子类还可以拥有自己专有的“内容”</p> </br>父类： </br>&emsp;&emsp;    也可以叫基类、超类 </br>子类： </br>&emsp;&emsp;    也可以叫派生类<p> </br>&emsp;&emsp;<br>  </br>&emsp;&emsp;<br>   </br>&emsp;&emsp;</p><p>继承的格式：<br> </br><br>/*<br> </br>&emsp;&emsp;<br>    在继承的关系中，“子类就是一个父类”。也就是说，子类可以被当作父亲看待<br></br>&emsp;&emsp;<br>    例如父类是员工，子类是讲师，那么“讲师就是一个员工”。关系：is-a</p><p>  </br>&emsp;&emsp;<br>定义父类的格式：（一个普通的类定义）<br> </br><br>public class 父类名称{<br> </br>&emsp;&emsp; &emsp;&emsp;<br>        // …<br>         </br><br>}</p> </br>子类定义的格式： </br>&emsp;&emsp;public class 子类名称 extends 父类名称 { </br>&emsp;&emsp; &emsp;&emsp;    // ... </br>    } </br>*/<hr><h5 id="代码区："><a href="#代码区：" class="headerlink" title="代码区："></a>代码区：</h5><h6 id="主程序："><a href="#主程序：" class="headerlink" title="主程序："></a>主程序：</h6><p>这段主要是父类子类的使用，还有重名变量，重名方法。还有的明天再更吧</p><pre><code class="hljs javascipt">public static void main(String[] args) &#123;       Fu fu &#x3D; new Fu();   &#x2F;&#x2F;创建父类对象       System.out.println(fu.FuNum);       &#x2F;&#x2F;等号左边是谁，就优先用谁       System.out.println(fu.num); &#x2F;&#x2F;重名       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       Zi zi &#x3D; new Zi();   &#x2F;&#x2F;创建子类对象       &#x2F;&#x2F;这里继承了父类的FuNum       System.out.println(zi.FuNum);   &#x2F;&#x2F;使用父类的FuNum       System.out.println(zi.num);       System.out.println(zi.ZiNum);       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       &#x2F;&#x2F;等号左边是谁，就优先用谁       System.out.println(zi.num); &#x2F;&#x2F;重名       &#x2F;&#x2F;这个方法是子类的，优先用子类的，没有再向上找       zi.methodZi();  &#x2F;&#x2F; 这是子类的方法30       &#x2F;&#x2F;这个方法是父类定义的       zi.methodFu();  &#x2F;&#x2F; 这是父类的方法10   &#125;</code></pre><h6 id="父类："><a href="#父类：" class="headerlink" title="父类："></a>父类：</h6><pre><code class="hljs javascipt">public class Fu &#123;    int num &#x3D; 10;    int FuNum &#x3D; 20;    public void methodFu()&#123;        &#x2F;&#x2F;使用的是父类当中的，不会向下找子类的        System.out.println(&quot;这是父类的方法&quot;+num);    &#125;&#125;</code></pre><h6 id="子类："><a href="#子类：" class="headerlink" title="子类："></a>子类：</h6><pre><code class="hljs javascipt">public class Zi extends Fu &#123;            &#x2F;&#x2F;继承父类    int num &#x3D; 30;    int ZiNum &#x3D; 50;    public void methodZi()&#123;        &#x2F;&#x2F;使用的是本类当中的num        System.out.println(&quot;这是子类的方法&quot;+num);    &#125;&#125;</code></pre><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Arrays和Math的使用</title>
    <link href="/2020/11/29/Arrays%E5%92%8CMath%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/29/Arrays%E5%92%8CMath%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="今天的内容其实收获甚多！"><a href="#今天的内容其实收获甚多！" class="headerlink" title="今天的内容其实收获甚多！"></a>今天的内容其实收获甚多！</h2><hr><p>今天就是Arrays和Math啦！</p><hr><h4 id="Arrays的使用："><a href="#Arrays的使用：" class="headerlink" title="Arrays的使用："></a>Arrays的使用：</h4></br>java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现常见的操作。</br></br><p>public static String toString(数组)：将参数数组变成一个字符串(按照默认格式：[元素1],[元素2],[元素3].。。。。)<br></br></br><br>public static void sort(数组)：按照默认升序(从小到大)对数组的元素进行排序。<br></br>&emsp;&emsp;<br>   备注：<br>   </br>&emsp;&emsp;<br>    1.如果是数值，sort默认按照升序从小到大<br>    </br>&emsp;&emsp;<br>    2.如果是字符串，sort默认按照字母升序<br>    </br>&emsp;&emsp;<br>    3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparable接口的支持。</p><h5 id="代码区："><a href="#代码区：" class="headerlink" title="代码区："></a>代码区：</h5><pre><code class="hljs javascipt">int[] intArray &#x3D; &#123;10,20,30&#125;;    &#x2F;&#x2F;将int[]数组按照默认格式变成字符串    String intStr &#x3D; Arrays.toString(intArray);    System.out.println(intStr);     &#x2F;&#x2F;[10, 20, 30]    int[] array1 &#x3D; &#123;2,1,5,4,9,8,3,5&#125;;    Arrays.sort(array1);    System.out.println(Arrays.toString(array1));        &#x2F;&#x2F;[1, 2, 3, 4, 5, 5, 8, 9]    &#x2F;&#x2F;倒叙遍历数组array1    for (int i &#x3D; array1.length - 1; i &gt;&#x3D; 0; i--) &#123;        System.out.println(array1[i]);    &#125;    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    String[] array2 &#x3D; &#123;&quot;bbb&quot;,&quot;ccc&quot;,&quot;aaa&quot;&#125;;    Arrays.sort(array2);    System.out.println(Arrays.toString(array2));        &#x2F;&#x2F;[aaa, bbb, ccc]</code></pre><hr><h4 id="Math的使用："><a href="#Math的使用：" class="headerlink" title="Math的使用："></a>Math的使用：</h4></br><p>java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。<br></br></p><p>public static double abs(double num)：获取绝对值。有多种重载。<br></br><br>public static double ceil(double num)：向下取整。<br></br><br>public static double floor(double num)：向下取整。<br></br><br>public static long round(double num)：四舍五入。</p><p></br></br><br>Math.PI 代表近似的圆周率常量(double)。</p><h5 id="代码区：-1"><a href="#代码区：-1" class="headerlink" title="代码区："></a>代码区：</h5><pre><code class="hljs javascipt">&#x2F;&#x2F;获取绝对值    System.out.println(Math.abs(3.14));  &#x2F;&#x2F; 3.14    System.out.println(Math.abs(0));     &#x2F;&#x2F; 0    System.out.println(Math.abs(-2.5));  &#x2F;&#x2F; 2.5    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#x2F;&#x2F;向下取整    System.out.println(Math.ceil(3.9));  &#x2F;&#x2F; 3.0    System.out.println(Math.ceil(3.1));  &#x2F;&#x2F; 3.0    System.out.println(Math.ceil(3.0));  &#x2F;&#x2F; 3.0    &#x2F;&#x2F;向下取整，抹零    System.out.println(Math.floor(30.1)); &#x2F;&#x2F; 30.0    System.out.println(Math.floor(30.9)); &#x2F;&#x2F; 30.0    System.out.println(Math.floor(31.0)); &#x2F;&#x2F; 31.0    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);    &#x2F;&#x2F;四舍五入    System.out.println(Math.round(20.4));  &#x2F;&#x2F; 20    System.out.println(Math.round(10.5));  &#x2F;&#x2F; 11    &#x2F;&#x2F;常量    System.out.println(Math.PI);            &#x2F;&#x2F; 3.1415....    int[] ar &#x3D; &#123;2,9,5,4,21,6321,2,52,852&#125;;    int a &#x3D; 100;    int b &#x3D; 20;    &#x2F;&#x2F; max比较两个数大小    System.out.println(Math.max(a,b));    System.out.println(Math.max(1,3));</code></pre><p>其实还顺便看了一下继承，但是这个得挤牙膏明天更        ^-^</p></br>其实总的来说今天可以学到更多，但是在某些个人原因浪费了诸多时间，这就很郁闷，这是一直以来的问题，我得不断的提醒自己。。。。。。<hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2020.11.28日志</title>
    <link href="/2020/11/28/2020-11-28%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/28/2020-11-28%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="今天学会了桥边姑娘，但是还是无所事事的一天"><a href="#今天学会了桥边姑娘，但是还是无所事事的一天" class="headerlink" title="今天学会了桥边姑娘，但是还是无所事事的一天"></a>今天学会了桥边姑娘，但是还是无所事事的一天</h2><hr><p>放心放心！！明天!明天！一定一定早早就起床！早早就起床记单词！早早就起床看英语演讲！<br>好了！我先去打两把王者</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2020.11.27日志</title>
    <link href="/2020/11/27/2020-11-27%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/27/2020-11-27%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="无所事事的一天"><a href="#无所事事的一天" class="headerlink" title="无所事事的一天"></a>无所事事的一天</h2><hr><p>还有就是static静态的使用</p><p>作图思路过程就是，这个静态区里存放着的是静态变量和静态方法，不在堆内存中的和对象无关。</p><p>还有就是静态代码块：</p><p>格式为：</p><pre><code class="hljs javascpit">public class 类名称&#123;static&#123;    &#x2F;&#x2F;静态代码块内容   &#125;&#125;</code></pre><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。<br>静态内容总是优先于非静态，所以静态代码块比构造方法先执行</p><p>静态代码块的典型用途：<br>用来一次性地对静态成员变量进行赋值。</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>static关键字(未完)</title>
    <link href="/2020/11/26/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2020/11/26/static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h2 id="今天学会万能的和弦！！能弹唱很多首歌，简直爱了爱了！！！"><a href="#今天学会万能的和弦！！能弹唱很多首歌，简直爱了爱了！！！" class="headerlink" title="今天学会万能的和弦！！能弹唱很多首歌，简直爱了爱了！！！"></a>今天学会万能的和弦！！能弹唱很多首歌，简直爱了爱了！！！</h2><hr><p>今天学习了static这个关键字<br>static静态变量：<br>他的应用范围是方便在类里完成全局的一个改变<br>static静态方法：<br>它的应用我暂时还不知道，但是简单的知道作用就是可以直接通过    类名称.静态方法名来使用</p><hr><h5 id="下面是写在记事本的知识点："><a href="#下面是写在记事本的知识点：" class="headerlink" title="下面是写在记事本的知识点："></a>下面是写在记事本的知识点：</h5><p>  一旦使用static修饰成员方法，那么这就成为了静态方法，静态方法不属于对象，而是属于类的</p><p>   如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。<br>   如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它</p><p>   无论是成员变量，还是成员方法，如果有了static，都推荐使用类名称进行调用</p><p>   //静态方法<br>//静态方法可以访问静态变量<br>问题：<br>1.静态不能直接访问非静态【重点】<br>    原因：因为在内存中【先】有静态内容，【后】有非静态内容。<br>“现任不知道后人，但是后人知道先人。”</p><p>2.静态方法当中不能用this<br>    原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。</p><hr><p>   下面为代码区：</p><h6 id="静态变量Student："><a href="#静态变量Student：" class="headerlink" title="静态变量Student："></a>静态变量Student：</h6><pre><code class="hljs javascpit">public class Student &#123;    private int id;     &#x2F;&#x2F;学号    private String name;    private int age;    static String room;    private static int idCounter &#x3D; 0;   &#x2F;&#x2F;计数器    public Student() &#123;        this.id &#x3D; ++idCounter;    &#125;    public Student(String name, int age) &#123;        this.name &#x3D; name;        this.age &#x3D; age;        this.id &#x3D; ++idCounter;    &#125;    public int getId() &#123;        return id;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public static String getRoom() &#123;        return room;    &#125;    public static void setRoom(String room) &#123;        Student.room &#x3D; room;    &#125;&#125;</code></pre><h6 id="静态变量Static："><a href="#静态变量Static：" class="headerlink" title="静态变量Static："></a>静态变量Static：</h6><p>使用</p><pre><code class="hljs javascpit">public class Static &#123;    public static void main(String[] args) &#123;        Student one &#x3D; new Student(&quot;卢本伟&quot;, 22);        &#x2F;&#x2F;只需要进行一次操作就好了        one.room &#x3D; &quot;101教室&quot;;        System.out.println(&quot;姓名：&quot;+one.getName()+&quot;，年龄：&quot;+one.getAge()+&quot;，教室：&quot;+one.room+&quot;，学号：&quot;+ one.getId());        Student two &#x3D; new Student(&quot;骚猪&quot;, 23);        System.out.println(&quot;姓名：&quot;+two.getName()+&quot;，年龄：&quot;+two.getAge()+&quot;，教室：&quot;+one.room+&quot;，学号：&quot;+ two.getId());    &#125;&#125;</code></pre><h6 id="静态方法Static-1："><a href="#静态方法Static-1：" class="headerlink" title="静态方法Static_1："></a>静态方法Static_1：</h6><pre><code class="hljs javascpit">public class Static_1 &#123;    int num;&#x2F;&#x2F;成员变量    static int numStatic;&#x2F;&#x2F;静态变量    public void method()&#123;        System.out.println(&quot;这是一个成员方法&quot;);        &#x2F;&#x2F;成员方法可以直接访问成员变量        System.out.println(num);        &#x2F;&#x2F;成员方法可以直接访问静态变量        System.out.println(numStatic);        System.out.println(&quot;这是this自己：&quot;+this);    &#125;    public static void methodStatic()&#123;        System.out.println(&quot;这是一个静态方法&quot;);        &#x2F;&#x2F;静态方法不能直接访非静态【重点】    &#x2F;&#x2F;    System.out.println(num);      &#x2F;&#x2F;错误写法        &#x2F;&#x2F;静态方法可以访问静态变量        System.out.println(numStatic);    &#x2F;&#x2F;    System.out.println(this); &#x2F;&#x2F;错误写法  &#x2F;&#x2F;this代表当前对象    &#x2F;&#x2F;      static方法会被强制翻译成 类名称.静态方法名       this表示对象，而静态方法不需要对象，两者冲突    &#125;&#125;</code></pre><h6 id="静态方法useStatic-1："><a href="#静态方法useStatic-1：" class="headerlink" title="静态方法useStatic_1："></a>静态方法useStatic_1：</h6><pre><code class="hljs javascpit">public static void main(String[] args) &#123;       Static_1 st1 &#x3D; new Static_1();&#x2F;&#x2F;首先创建对象       &#x2F;&#x2F;然后才能使用没有static关键字的内容       st1.method();       &#x2F;&#x2F;对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用       st1.methodStatic();     &#x2F;&#x2F;正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”       Static_1.methodStatic();&#x2F;&#x2F;正确，推荐       &#x2F;&#x2F;对于本类当中的静态方法，可以省略类名称       myMethod();       useStatic_1.myMethod();&#x2F;&#x2F;完全等效   &#125;   public static void myMethod()&#123;       System.out.println(&quot;这是自己的方法&quot;);   &#125;</code></pre><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串，类，数组练习题</title>
    <link href="/2020/11/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%B1%BB%EF%BC%8C%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>/2020/11/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%B1%BB%EF%BC%8C%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="今天就写了一道练习题，在复习过往知识呀！"><a href="#今天就写了一道练习题，在复习过往知识呀！" class="headerlink" title="今天就写了一道练习题，在复习过往知识呀！"></a>今天就写了一道练习题，在复习过往知识呀！</h2><hr><h4 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h4><p> </br>&emsp;&emsp;<br>   定义两个方法，把键入放到数组并按照一定格式拼接成一个字符串。<br>    </br>&emsp;&emsp;<br>   格式参照如下[word1#word2#word3]</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><p> </br>&emsp;&emsp;</p> <pre><code class="hljs javascipt">   public static void main(String[] args) &#123;        &#x2F;&#x2F;调用sc          sc键入三个参数String类型的        getBig(sc());    &#125;        &#x2F;&#x2F;  键入三个数返回给sc    public static ArrayList&lt;String&gt; sc()&#123;        Scanner sc &#x3D; new Scanner(System.in);        System.out.println(&quot;请键入第一个数：&quot;);        String xx &#x3D; sc.next();        System.out.println(&quot;请键入第二个数：&quot;);        String aa &#x3D; sc.next();        System.out.println(&quot;请键入第三个数：&quot;);        String bb &#x3D; sc.next();        ArrayList&lt;String&gt; word &#x3D; new ArrayList&lt;&gt;();        word.add(xx);        word.add(aa);        word.add(bb);        for (int i &#x3D; 0; i &lt; word.size(); i++) &#123;            System.out.println(word.get(i));        &#125;        System.out.println(word.size());        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        return word;    &#125;    public static ArrayList&lt;Integer&gt; getBig (ArrayList&lt;String&gt; dyArray) &#123;                &#x2F;&#x2F;number是用来接受返回值的，不应该直接使用        ArrayList&lt;Integer&gt; number &#x3D; new ArrayList&lt;&gt;();        System.out.print(&quot;[&quot;);        for (int i &#x3D; 0; i &lt; dyArray.size(); i++) &#123;                &#x2F;&#x2F; 用get方法获得sc传入的字符串然后进行修改操作            System.out.print(&quot;word&quot;+dyArray.get(i)+&quot;#&quot;);        &#125;        System.out.print(&quot;]&quot;);        System.out.println(&quot; &quot;);        return number;    &#125;    &#x2F;&#x2F;            ArrayList&lt;String&gt; oo &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;            oo.add(&quot;AAA&quot;);&#x2F;&#x2F;            oo.add(&quot;BBB&quot;);&#x2F;&#x2F;            oo.add(&quot;CCC&quot;);&#x2F;&#x2F;            oo.add(&quot;DDD&quot;);    &#x2F;&#x2F;get表示获取索引值1的数    &#x2F;&#x2F;System.out.println(oo.get(1));&#125;</code></pre><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串最后进阶</title>
    <link href="/2020/11/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E8%BF%9B%E9%98%B6/"/>
    <url>/2020/11/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9C%80%E5%90%8E%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="今晚要讲到字符串的最后进阶啦"><a href="#今晚要讲到字符串的最后进阶啦" class="headerlink" title="今晚要讲到字符串的最后进阶啦!"></a>今晚要讲到字符串的最后进阶啦!</h2><hr><p>字符串的三种方法</p><ul><li> 字符串的截取方法</li><li> 分割字符串的方法</li><li> String当中与转换相关的常用方法</li></ul><p>下面将会详细展开方法使用的讲解：</p><hr><h4 id="字符串的截取方法："><a href="#字符串的截取方法：" class="headerlink" title="字符串的截取方法："></a>字符串的截取方法：</h4><p></br>&emsp;&emsp;<br> public String substring(int index): 截取从参数位置一直到字符串末尾，返回新的字符串。<br> </br>&emsp;&emsp;<br>    public String substring(int begin,int end): 截取从begin开始，一直到end结束，中间的字符串。<br>    </br>&emsp;&emsp;<br>    备注：[begin,end],包含坐标，不包含右边。</p><p>   重！：字符串永远不可变，如果你看着发生了改变，那这是开辟了新内存<br>     </br></p><h6 id="代码演示区："><a href="#代码演示区：" class="headerlink" title="代码演示区："></a>代码演示区：</h6><pre><code class="hljs javascipt">public static void main(String[] args) &#123;       String str1 &#x3D; &quot;HelloWorld&quot;;       String str2 &#x3D; str1.substring(5);       System.out.println(str1);       System.out.println(str2);       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       String str3 &#x3D; str1.substring(4, 7);       System.out.println(str3);       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       &#x2F;&#x2F;下面这种写法，字符串的内容仍然是没有改变的       &#x2F;&#x2F;下面有两种字符串：“Hello”  ,   “Java”       &#x2F;&#x2F;本来的地址值是Hello的0x666       &#x2F;&#x2F;后来地址值变成了Java的0x999       String strA &#x3D; &quot;Hello&quot;;       System.out.println(strA);   &#x2F;&#x2F;Hello       strA &#x3D; &quot;Java&quot;;       System.out.println(strA);   &#x2F;&#x2F;Java   &#125;</code></pre><hr><h4 id="分割字符串的方法："><a href="#分割字符串的方法：" class="headerlink" title="分割字符串的方法："></a>分割字符串的方法：</h4>  </br>   public String[] split(String regex):    &emsp;&emsp; 按照参数的规则，将字符串切分成为若干部分。<p>   注意事项：<br>     </br>&emsp;&emsp;<br>   split方法的参数其实就是一个“正则表达式”。<br>     </br>&emsp;&emsp;<br>   今天要注意：如果按照英文句点“.”进行切分，必须写“\.”（两个反斜杠）</p>   </br>   ###### 代码演示区：<pre><code class="hljs javascipt">    public static void main(String[] args) &#123;        String str1 &#x3D; &quot;aaa,bbb,ccc&quot;;        String[] array1 &#x3D; str1.split(&quot;,&quot;);        for (int i &#x3D; 0; i &lt; array1.length; i++) &#123;            System.out.println(array1[i]);        &#125;        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);            &#x2F;&#x2F;数组需要遍历！        String str2 &#x3D;&quot;AAA.BBB.CCC&quot;;        String[] array2 &#x3D; str2.split(&quot;\\.&quot;);        for (int i &#x3D; 0; i &lt; array2.length; i++) &#123;            System.out.println(array2[i]);        &#125;            &#x2F;&#x2F;错误写法&#x2F;&#x2F;         String[] array2 &#x3D; str2.split(&quot;.&quot;);&#x2F;&#x2F;         System.out.println(array2.length);          &#x2F;&#x2F;  0    &#125;</code></pre><hr><h4 id="String当中与转换相关的常用方法"><a href="#String当中与转换相关的常用方法" class="headerlink" title="String当中与转换相关的常用方法:"></a>String当中与转换相关的常用方法:</h4><p></br>&emsp;&emsp;<br>   public char[] toCharArray(): 将当前字符串拆分为字符串数组作为返回值<br></br>&emsp;&emsp;<br>   public byte[] getBytes():    获得当前字符串底层的字节数组<br></br>&emsp;&emsp;<br>   public String replace(CharSequence oldString,CharSequence newString):<br></br>&emsp;&emsp;<br>   将所有出现的老字符串替换成为新的字符串，返回替换之后的新字符串<br></br>&emsp;&emsp;<br>   备注：CharSequence意思就是说可以接受字符串类型。</p><h6 id="代码演示区：-1"><a href="#代码演示区：-1" class="headerlink" title="代码演示区："></a>代码演示区：</h6><pre><code class="hljs javascipt">public static void main(String[] args) &#123;       &#x2F;&#x2F;转换成为字符串数组       char[] chars &#x3D; &quot;Hello&quot;.toCharArray();       &#x2F;&#x2F;打印chars的索引0       System.out.println(chars[0]);   &#x2F;&#x2F;H       &#x2F;&#x2F;打印chars数组的长度       System.out.println(chars.length); &#x2F;&#x2F;5       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       &#x2F;&#x2F;转换为字节数组       byte[] bytes &#x3D; &quot;abc&quot;.getBytes();       &#x2F;&#x2F;遍历bytes里的底层字节数组           为97 98 99       for (int i &#x3D; 0; i &lt; bytes.length; i++) &#123;           System.out.println(bytes[i]);       &#125;       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       &#x2F;&#x2F;字符串内容的替换       String str1 &#x3D; &quot;How do you do&quot;;       &#x2F;&#x2F;将所有&quot;o&quot; 替换为 &quot;*&quot;       String str2 &#x3D; str1.replace(&quot;o&quot;,&quot;*&quot;);       System.out.println(str1);       System.out.println(str2);       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       String lang1 &#x3D; &quot;会不会玩啊！你大爷的！你大爷的！你大爷的！&quot;;       String lang2 &#x3D; lang1.replace(&quot;你大爷的&quot;,&quot;****&quot;);       System.out.println(lang2);   &#125;</code></pre><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020.11.23日志</title>
    <link href="/2020/11/23/2020-11-23%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/23/2020-11-23%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="今天学费了天空之城的第一段的第一小小小节！！！"><a href="#今天学费了天空之城的第一段的第一小小小节！！！" class="headerlink" title="今天学费了天空之城的第一段的第一小小小节！！！"></a>今天学费了天空之城的第一段的第一小小小节！！！</h2><hr><p>今日更新内容有：</p><ul><li>哲学</li><li>字符串的进阶二（字符串要详学）</li><li>今天好像没有练习题</li></ul><hr><h4 id="哲学："><a href="#哲学：" class="headerlink" title="哲学："></a>哲学：</h4><p></br>&emsp;&emsp;<br>今天依旧是来说权力在交流当中起到的作用<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;<br>很多时候我们接收到的意义！<br></br>&emsp;&emsp;<br>并不是我们分析和理解出来的<br></br>&emsp;&emsp;<br>而是被构建起来的！<br></br>&emsp;&emsp;<br>这个构建它围绕着意识形态，我们的权力结构，当然还有一些个人所知的信息差；<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;<br>分为：<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;<br>    【发出者】意图意义（这个意义是由发起人想要表达的意义）<br>    </br>&emsp;&emsp;<br>    |<br>    </br>&emsp;&emsp;<br>    |<br>    </br>&emsp;&emsp;<br>    |<br>    </br>&emsp;&emsp;<br>    V<br>    </br>&emsp;&emsp;<br>   文本意义（这里是交流的媒介，意义通过这里传播给接受意义的人）<br>        </br>&emsp;&emsp;<br>    |<br>    </br>&emsp;&emsp;<br>    |<br>    </br>&emsp;&emsp;<br>    |<br>    </br>&emsp;&emsp;<br>    V<br>    </br>&emsp;&emsp;<br>   【接收者】解释意义，这里经过的媒介就相当于两者处在不同的（社会阶级）（认知范围）（意识形态）都会导致接收者所想得到的意义会有所不同</p><p>   </br>&emsp;&emsp;<br>   </br>&emsp;&emsp;<br>   </br>&emsp;&emsp;<br>   若是想避免这种错误的出现：</p><p>   </br>&emsp;&emsp;<br>   1.强调文本意义缩减范围（发出者）<br>   </br>&emsp;&emsp;<br>   2.我们要用更广大的语境来分析语义（接收者）<br>   </br>&emsp;&emsp;<br>   3.达成某种共识（集体共识）</p><p>  </br>&emsp;&emsp;</br>&emsp;&emsp;</br>&emsp;&emsp;</br>&emsp;&emsp;</br>&emsp;&emsp;</br>&emsp;&emsp;<br>  还有一点需要特别注意！！！！！！<br>  </br>&emsp;&emsp;在交流当中！！！！<br>  </br>&emsp;&emsp;这是非常值得注意的！！！！！<br>  </br>&emsp;&emsp;==<br>  </br>&emsp;&emsp;直接谈及权力是非常危险的东西，会直接取消语言游戏的暧昧性，让权力关系赤裸裸的暴露出来</p><hr><h4 id="字符串的进阶操作二之获取"><a href="#字符串的进阶操作二之获取" class="headerlink" title="字符串的进阶操作二之获取"></a>字符串的进阶操作二之获取</h4><p>   String当中与获取相关的方法常有：<br>    </br>&emsp;&emsp;<br>    public int length():    获取字符串当中含有的字符个数，拿到字符串长度。<br>     </br>&emsp;&emsp;<br>    public String concat(String str):   将当前字符串和参数字符串拼接成为返回值新的字符串。<br>     </br>&emsp;&emsp;<br>    public char charAt(int index):  获取指定索引位置的单个字符。（索引从0开始）<br>     </br>&emsp;&emsp;<br>    public int indexOf(String str):     查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值<br>     </br>&emsp;&emsp;</p><p></br>&emsp;&emsp;</p><h5 id="代码详解："><a href="#代码详解：" class="headerlink" title="代码详解："></a>代码详解：</h5><pre><code class="hljs javascipt">public static void main(String[] args) &#123;        &#x2F;&#x2F; public int length():        &#x2F;&#x2F; 获取字符串长度        int length &#x3D; &quot;sadkjashdfkjahf&quot;.length();        System.out.println(&quot;字符串长度是：&quot;+length);        &#x2F;&#x2F; 拼接字符串        &#x2F;&#x2F; public String concat(String str):        String str1 &#x3D; &quot;Hello&quot;;        String str2 &#x3D; &quot;World&quot;;        String str3 &#x3D; str1.concat(str2);        System.out.println(str1);        System.out.println(str2);        System.out.println(str3);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);        &#x2F;&#x2F;  获取指定索引位置的单个字符        &#x2F;&#x2F; public char charAt(int index):        char ch &#x3D; &quot;Hello&quot;.charAt(1);        &#x2F;&#x2F;传入需要获取的索引        System.out.println(&quot;在1号索引位置的字符是：&quot;+ch);        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       &#x2F;&#x2F; public int indexOf(String str):       &#x2F;&#x2F; 查找参数字符串在本来字符串当中出现的第一次索引位置       &#x2F;&#x2F; 如果根本没有，返回-1值        String original &#x3D; &quot;HelloHelloWorld&quot;;        int index &#x3D; original.indexOf(&quot;llo&quot;);&#x2F;&#x2F;如果找到了llo  后面则不会再找        System.out.println(&quot;第一次索引值是：&quot;+index);          &#x2F;&#x2F;2        System.out.println(&quot;HelloWorld&quot;.indexOf(&quot;abc&quot;));   &#x2F;&#x2F; -1    &#125;</code></pre><h4 id="字符串的进阶操作二之比较"><a href="#字符串的进阶操作二之比较" class="headerlink" title="字符串的进阶操作二之比较"></a>字符串的进阶操作二之比较</h4><p>   ==是进行对象的地址值比较，如果确实需要字符串的内容比较，可以使用两个方法<br>      </br>&emsp;&emsp;</p><p>方法一：<br>   </br>&emsp;&emsp;<br>   public boolean equals(Object obj): 参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给ture;否则返回false。<br>      </br>&emsp;&emsp;<br>   注意事项：<br>      </br>&emsp;&emsp;<br>   1.任何对象都能用Object进行接收。<br>      </br>&emsp;&emsp;<br>   2.equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样<br>      </br>&emsp;&emsp;<br>   3.如果比较双方一个常量一个变量，推荐把常量字符串写在前面。<br>      </br>&emsp;&emsp;<br>      </br>&emsp;&emsp;<br>   推荐：”abc”.equals(str)<br>      </br>&emsp;&emsp;<br>      不推荐：str.equals(“abc”)</p><p>方法二：<br>   </br>&emsp;&emsp;<br>    public boolean equalsIgnoreCase(String str)：忽略大小写，进行内容比较。</p><h5 id="代码详解：-1"><a href="#代码详解：-1" class="headerlink" title="代码详解："></a>代码详解：</h5><pre><code class="hljs javascipt">public static void main(String[] args) &#123;       String str1 &#x3D; &quot;Hello&quot;;       String str2 &#x3D; &quot;Hello&quot;;       char[] charArray &#x3D; &#123;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;;       String str3 &#x3D; new String(charArray);       System.out.println(str1.equals(str2));  &#x2F;&#x2F;true       System.out.println(str2.equals(str3));  &#x2F;&#x2F;true       System.out.println(str3.equals(&quot;Hello&quot;));  &#x2F;&#x2F;true       equals严格区分大小写       System.out.println(&quot;Hello&quot;.equals(str1));   &#x2F;&#x2F;true       String str4 &#x3D; &quot;hello&quot;;       System.out.println(str1.equals(str4));       System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);       String str5 &#x3D; null;       System.out.println(&quot;abc&quot;.equals(str5)); &#x2F;&#x2F;推荐: false       &#x2F;&#x2F;     System.out.println(str5.equals(&quot;abc&quot;)); &#x2F;&#x2F;不推荐: 报错，空指针异常NullPrinterException       String strA &#x3D; &quot;Java&quot;;       String strB &#x3D; &quot;java&quot;;       System.out.println(strA.equals(strB));  &#x2F;&#x2F; false: 严格区分大小写       System.out.println(strA.equalsIgnoreCase(str5));  &#x2F;&#x2F;true：忽略大小写，但是只对字母不区分，对中文会false   &#125;</code></pre><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2020.11.22日志</title>
    <link href="/2020/11/22/2020-11-22%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/22/2020-11-22%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="不会在主题选择花费很多时间"><a href="#不会在主题选择花费很多时间" class="headerlink" title="不会在主题选择花费很多时间"></a>不会在主题选择花费很多时间</h2><hr><p>今天依旧没有上上星期的那股劲，在学习方面还得努力呀！<br></br>&emsp;&emsp;</p><p>今日的知识点是：    哲学，有字符串的深入讨论，还有练习题<br></br>&emsp;&emsp;</p><p>先说说哲学吧！</p><hr><h4 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h4><p>先引导两句比较有哲理的话：<br>    </br>&emsp;&emsp;</p><ul><li><p>每句话都是权力的游戏<br></br>&emsp;&emsp;</p></li><li><p>说话是使用语言符号产生意义的活动，但一句话到底，有什么意义，最终取决于<del>谁有—–</del>最终解释权~~<br></br></br> </br></br><br>有一个关于权力交流的五行图：<br></br>&emsp;&emsp;<br>我没有弄图床，所以不能上传图片表示</p><p></br>&emsp;&emsp;</p></li><li><p>演讲—权力的形成（吸引，焦距与引导）<br></br>&emsp;&emsp;</p></li><li><p>辩论—权力在他方（双方权力决定胜负，通常由中立第三方裁决）<br></br>&emsp;&emsp;</p></li><li><p>沟通—权力在流动（避免冲撞与协调转向）<br></br>&emsp;&emsp;</p></li><li><p>说服—权力在对方（无权的乙方要改变有权的一方）<br></br>&emsp;&emsp;</p></li><li><p>谈判—权力在双方（双方要合作，才能解决问题）</p><p></br>&emsp;&emsp;</br>&emsp;&emsp;<br>^意识形态就是服务于权力的意义^</p><p></br>&emsp;&emsp;</p><p>感觉还有一部分可以挤牙膏，今天讲了权力在交流中存在的方式</p></li></ul><hr><h4 id="字符串的进阶一"><a href="#字符串的进阶一" class="headerlink" title="字符串的进阶一"></a>字符串的进阶一</h4><p>  </br></br><br>java.lang.String类代表字符串。<br></br></br><br>API当中说：Java程序中的所有字符串字面值（如“abc”）都作为此类的实例实现。<br></br></br><br>其实就是说：程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。）<br></br><br></br><br>字符串的特点：<br></br>&emsp;&emsp;<br>    1.字符串的内容永不可变。【重点】<br>    </br>&emsp;&emsp;<br>    2.正是因为字符串不可改变，所有字符串是可以共享使用的。<br>    </br>&emsp;&emsp;<br>    3.字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。<br></br></br><br>创建字符串的常见3+1种方式：<br></br>&emsp;&emsp;<br>    三种构造方法：<br>    </br>&emsp;&emsp;</p><ul><li>public String()；    创建一个空白字符串，不含有任何内容。<br>  </br>&emsp;&emsp;</li><li>public String(char[] array)；    根据字符数组的内容，来创建对应的字符串。<br>  </br>&emsp;&emsp;</li><li>public String(byte[] array)；    根据字符数组的内容，来创建对应的字符串。<br>  </br>&emsp;&emsp;</li></ul><p>一种直接创建：<br>    </br>&emsp;&emsp;<br> String str =”Hello”;        // 右边直接用双引号</p><hr><h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><span class="hljs-comment">    题目：</span><span class="hljs-comment">        用一个大集合存入20个随机数数字，然后筛选其中的偶数元素，放到小集合中</span><span class="hljs-comment">        ***要求使用自定义的方法实现筛选</span><span class="hljs-comment"></span><span class="hljs-comment">    解决思路：</span><span class="hljs-comment">        1.先创建一个大集合来储存，Random的随机数</span><span class="hljs-comment">        2.自定义方法实现偶素筛选</span><span class="hljs-comment"> */</span></code></pre><h5 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h5><pre><code class="hljs javascript">public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;          <span class="hljs-comment">//1. 创建大集合     bigAggregate</span>      ArrayList&lt;Integer&gt; bigAggregate = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      Random r = <span class="hljs-keyword">new</span> Random();      <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;          <span class="hljs-comment">//2. add方法来把随机数加进大集合里</span>          bigAggregate.add(r.nextInt(<span class="hljs-number">100</span>)+<span class="hljs-number">1</span>);      &#125;          <span class="hljs-comment">//7. 先把bigAggregate传入getBig让它处理数据得到偶数</span>      ArrayList&lt;Integer&gt; ok = getBig(bigAggregate);          <span class="hljs-comment">//8. 用for循环遍历ok内的偶数</span>      <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; ok.size(); i++) &#123;          <span class="hljs-comment">//  错误写法：System.out.println(ok);    返回的依旧是： [98, 100, 40, 60, 66, 28, 8, 68]</span>          <span class="hljs-comment">//要用get.方法</span>          System.out.print(<span class="hljs-string">&quot;,&quot;</span>+ok.get(i));          <span class="hljs-comment">// 返回值正确：,28,88,24,34,58,72,6,10,52,80,58,14</span>      &#125;      <span class="hljs-comment">// System.out.println(getBig(bigAggregate));        这样写得到的结果为：[98, 100, 40, 60, 66, 28, 8, 68]</span>  &#125;         <span class="hljs-comment">//3.       ok       方法名是待会要用来调用的                  参数名是传入的参数要用到的</span>  public <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; getBig (ArrayList&lt;Integer&gt; numbers)&#123;              <span class="hljs-comment">//4. 创建了一个小的集合来作为接收后返回给ok</span>      ArrayList&lt;Integer&gt; small = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; numbers.size(); i++) &#123;          <span class="hljs-comment">//5. 用get方法就能得到numbers给的数值</span>          int x = numbers.get(i);          <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;              small.add(x);          &#125;      &#125;          <span class="hljs-comment">//6. 反回small的值给方法getBig</span>      <span class="hljs-keyword">return</span> small;  &#125;</code></pre><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2020.11.21日志</title>
    <link href="/2020/11/21/2020-11-21%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/21/2020-11-21%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="倒不如不曾遇见-天各两端"><a href="#倒不如不曾遇见-天各两端" class="headerlink" title="倒不如不曾遇见~天各两端"></a>倒不如不曾遇见~天各两端</h2><hr><p>&emsp;&emsp;<br>今晚不知道怎么了，时间太多，学学又玩玩的，导致现在23:09连算法导论都没有看，害，真是的，今晚这是怎么了。又要变成一个奇怪的人了么？</p><p></br>&emsp;&emsp;<br>人呐，就是不能闲下来，一闲下来就觉得自己吃得太饱了，啥都想，哈哈<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;</p><hr><p><del>我走在城南的关</del><br></br><br><del>看着月下的帆</del><br></br><br><del>人为情而月下感叹</del><br></br><br><del>倒不如不曾遇见</del><br></br><br><del>天各两端</del></p><hr><h3 id="下面是哲学："><a href="#下面是哲学：" class="headerlink" title="下面是哲学："></a>下面是哲学：</h3><h4 id="符号转译交流的基本规则："><a href="#符号转译交流的基本规则：" class="headerlink" title="符号转译交流的基本规则："></a>符号转译交流的基本规则：</h4><p>   ·权力结构<br>   </br><br>   ·交往预期<br>   </br><br>   ·欲望张力<br></br><br>这一章有两个对于平等权利结构很有名的句子：<br></br>&emsp;&emsp;<br>1.他人即是地狱<br></br>&emsp;&emsp;<br>2.世界上总有他人面对我在场，并且我总有为他存在的一维。<br></br>&emsp;&emsp;&emsp;&emsp;<br>这是本体论上的必然无疑性<br></br></br></br><br>还有对于交流中权力的流动的理解，这个到明天我再发吧，挤挤牙膏，嘻嘻</p><hr><h3 id="今日练习题"><a href="#今日练习题" class="headerlink" title="今日练习题"></a>今日练习题</h3><h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><pre><code class="hljs javascript">题目：定义四个学生对象，添加到集合，并遍历思路：<span class="hljs-number">1.</span> 自定义Student学生类，四部分。<span class="hljs-number">2.</span> 创建一个集合，用来储存学生对象，泛型：&lt;Student0&gt;<span class="hljs-number">3.</span>根据类，创建<span class="hljs-number">4</span>个学生对象<span class="hljs-number">4.</span> 将<span class="hljs-number">4</span>个学生对象添加到集合中：add<span class="hljs-number">5.</span> 遍历集合：<span class="hljs-keyword">for</span>、size、get</code></pre><h5 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h5><pre><code class="hljs javascript">public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;    <span class="hljs-comment">// 1. 学生类创建好了</span>    <span class="hljs-comment">// 2. 集合student创建完成     为泛型：Student</span>    ArrayList&lt;Student&gt; student =<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-comment">// 3. 四个对象创建</span>    Student one = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;迪丽热巴&quot;</span>,<span class="hljs-number">20</span>);    Student tow = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>,<span class="hljs-number">21</span>);    Student three = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;杨幂&quot;</span>,<span class="hljs-number">22</span>);    Student four = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;我&quot;</span>,<span class="hljs-number">19</span>);    <span class="hljs-comment">// 4. 将四个对象加入集合当中</span>    student.add(one);    student.add(tow);    student.add(three);    student.add(four);    <span class="hljs-comment">// 5. 遍历对象student</span>    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; student.size(); i++) &#123;        Student stu = student.get(i);        System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span> + stu.getName() + <span class="hljs-string">&quot;，年龄：&quot;</span>+stu.getAge());    &#125;&#125;</code></pre><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList的使用</title>
    <link href="/2020/11/20/2020-11-20%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/20/2020-11-20%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="ArrayList的使用"><a href="#ArrayList的使用" class="headerlink" title="ArrayList的使用"></a>ArrayList的使用</h2><hr><p>ArrayList：<br>        </br>&emsp;&emsp;<br>    数组的长度不可以发生改变。<br>      </br>&emsp;&emsp;<br>    但是ArrayList集合的长度是可以随意变化的。<br></br></br></br><br>对于ArrayList来说，有一个尖括号<E>代表泛型。</p></br>泛型：也就是装在集合当中的所有元素，全都是统一的什么类型</br>注意：泛型只能是引用类型，不能是基本类型<hr></br>如果希望向集合ArrayList当中储存基本数据类型，必须使用基本类型对应的“包装类”<table><thead><tr><th>基本类型</th><th>包装类（引用类型，包装类都位于java.lang包下）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer        【特殊】</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character    【特殊】</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>从JDK  1.5+开始，支持自动装箱、自动拆箱。</p><p>自动装箱：基本类型 –&gt; 包装类型<br>自动拆箱：包装类型 –&gt; 基本类型</p><hr><h4 id="ArrayList的代码区："><a href="#ArrayList的代码区：" class="headerlink" title="ArrayList的代码区："></a>ArrayList的代码区：</h4><pre><code class="hljs javascript">public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;       <span class="hljs-comment">//      &lt;&gt;放着什么 这个就是什么类型的</span>       ArrayList&lt;<span class="hljs-built_in">String</span>&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();       <span class="hljs-comment">//  ArrayList&lt;int&gt; list1 = new ArrayList&lt;&gt;();           错误写法</span>       ArrayList&lt;Integer&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();       <span class="hljs-comment">// int x = list2.add(100);</span>       list2.add(<span class="hljs-number">100</span>);       list2.add(<span class="hljs-number">200</span>);       list2.add(<span class="hljs-number">300</span>);       list2.add(<span class="hljs-number">400</span>);       System.out.println(list2);       System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);       <span class="hljs-comment">//  现在尝试    获取索引 2</span>       int x = list2.get(<span class="hljs-number">2</span>);       System.out.println(x);       System.out.println(<span class="hljs-string">&quot;==================================================&quot;</span>);       <span class="hljs-comment">//  list.add   一次只能放一个</span>       list.add(<span class="hljs-string">&quot;我&quot;</span>);       <span class="hljs-comment">//</span>       list.add(<span class="hljs-string">&quot;你&quot;</span>);       <span class="hljs-comment">//</span>       list.add(<span class="hljs-string">&quot;他&quot;</span>);       System.out.println(list);       System.out.println(<span class="hljs-string">&quot;===============================================&quot;</span>);   &#125;</code></pre><hr><h4 id="个人练习代码区"><a href="#个人练习代码区" class="headerlink" title="个人练习代码区"></a>个人练习代码区</h4><pre><code>### 问题描述：        生成6个1~33之间的随机数，添加到集合，并遍历集合        思路：        1.用Random先生成6个随机数        2.然后用ArrayList收录生成的随机数        3.再用for遍历集合</code></pre><h6 id="下面为解决区："><a href="#下面为解决区：" class="headerlink" title="下面为解决区："></a>下面为解决区：</h6><pre><code class="hljs javascript">public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;        int x;        int y = <span class="hljs-number">0</span>;        Random r = <span class="hljs-keyword">new</span> Random();        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        stop:<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;            <span class="hljs-keyword">if</span> (y != <span class="hljs-number">7</span>) &#123;                x = r.nextInt(<span class="hljs-number">34</span>);                list.add(x);                System.out.println(<span class="hljs-string">&quot;现在执行第：&quot;</span>+y+<span class="hljs-string">&quot;次&quot;</span>);                ++y;                System.out.println(list);            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span> stop;            &#125;        &#125;        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;            System.out.println(list.get(i));        &#125;    &#125;</code></pre><hr><p>今天的时间比较多呀，嘻嘻，11点就更完了<br></br><br>还在努力，写了个在校时间作息表，插入了很多东西，每天的时间也是排的满满的，很他妈充实！！！！！<br></br><br>最后再给自己的自律加个油！！！！！！！！！！！！！！！！！！！</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020.11.19日志</title>
    <link href="/2020/11/19/2020-11-19%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/19/2020-11-19%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="关于今天的日志"><a href="#关于今天的日志" class="headerlink" title="关于今天的日志"></a>关于今天的日志</h2><hr><p>今天晚上基本上啥都没学成，到现在我衣服还放在盆里没凉，我深思，是我时间不够嘛，今天的事确实有点多，但是总不至于没时间学习和更新新知识。问题还是出在了自身，我还不够自律，要更努力才行！！！！</p></br>要努力学习啊待会真的看两页算法导论，今天好难啊！！！<hr><p> <del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2020.11.18日志</title>
    <link href="/2020/11/18/2020-11-18%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/18/2020-11-18%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="2020-11-18日志"><a href="#2020-11-18日志" class="headerlink" title="2020.11.18日志"></a>2020.11.18日志</h2><hr><p>今天没有进行新的学习，倒是看了一下对象数组，</p></br>下面来看看我今晚放学回来的时间规划：（必然划水了很多时间）<p>晚上：<br></br>&emsp;&emsp;<br>5:00————回到宿舍<br></br>&emsp;&emsp;<br>7:00————完善了张三的每月消费打工的记录表任务（心里高兴—–这个时间断在划水）</p><p></br>&emsp;&emsp;</p><p></br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>                《神秘的三个小时，我竟然在划水》</p><p>=========================就是从这开始断掉的，别的时间都有详细的记录</p></br>以下为时间段内的的用时：</br>&emsp;&emsp;看B站学习视频：</br>&emsp;&emsp;&emsp;&emsp;    对象数组：8分钟</br>7:00 - 10:00这个时间段在划水！！！！！！！！！！！！！划水了三个小时！！！！！！！</br>三个小时能干很多东西了，我的天！！！！！！！！！！！！</br><p>10:00———–在B站看了编程的13大误区，这个时间断花了30分钟（虽然，很多道理都懂，但是还是有一些收获的）<br></br><br>10:30———–开始写博</p></br><p>==================================神秘分割线=======================================</p><p>最后是总结的13大误区：<br></br></br><br>1.计算机基础很重要，很重要<br></br></br><br>2.选择适合自己的语言，不纠结，不同语言适用场景不同，不同语言逻辑语法大同小异，触类旁通，推荐学JAVA，简单上手并好就业一些<br></br></br><br>3.动手写代码非常重要，光看不练白搭<br></br></br><br>4.懂了和会用不一样，会应用才是真的懂了<br></br></br><br>5.学习要有笔记、思维导图或代码记录，有自己的想法积累或总结，长期以往就会把精华学进脑内，就会知道怎么解决问题或者知道解决问题需要用哪段代码，最后就有了自己的学习方法<br></br></br><br>6.不要全部死记硬背，不变的语法，结构等需要背下来，其他功能性的内容知道在哪或者怎么找到解决办法就行了，实在理解不了就硬背然后实践中理解<br></br></br><br>7.报错一定不要逃避，这是提高自己能力的重要方法，排除错误才会提升能力也会避免犯错<br></br></br><br>8.不要闭门造车，敢于交流分享，交流分享技术很重要，不要让自己成为井底之蛙，很多问题别人也许有特别好的解决办法，不怕嘲笑，都是过来人，越战越勇！<br></br></br><br>9.不要跟风新技术，学习技术要建立体系，要有精通的技术和竞争力，用有限的时间做高效的事，定好学习目标和方向<br></br></br><br>10.别让收藏夹吃灰，别让磁盘充满也不学习，资源在精不在多，同上，规划好学习目标<br></br></br><br>11.学编程同性别无关，职场中女生有劣势，做好职业规划<br></br></br><br>12.学编程和专业无关，技术和业务逻辑分离，都重要<br></br></br><br>13.数学不好不是学不好编程的借口，绝大多数程序员不需要用到高深的数学知识，除非是算法、大数据等方向<br>树立目标，前进就是进步</p><p></br>好啦好啦！！！！！三个小时啊！！！今晚划水太多了！！！！！！！保证以后减少划水时间！！！！<br></br>加油！！！！！</p><hr><p> <del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2020.11.17日志</title>
    <link href="/2020/11/17/2020-11-17%E6%97%A5%E5%BF%97/"/>
    <url>/2020/11/17/2020-11-17%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h2 id="关于今天的事情-emsp-emsp-11-18更新完整张三代码"><a href="#关于今天的事情-emsp-emsp-11-18更新完整张三代码" class="headerlink" title="关于今天的事情        &emsp;&emsp;11.18更新完整张三代码"></a>关于今天的事情        &emsp;&emsp;11.18更新完整张三代码</h2><hr><p></br>&emsp;&emsp;<br>吐槽一下我的编程课老师，晚上8：30问的问题，现在10：31分，老师连回都不愿意回我，我特么，是我问的问题太NT了嘛，我吐了，看来老师今天是不会回我了。<br></br>&emsp;&emsp;<br>今天依旧没学习新知识，在复习，下午放学回来就一直在敲，坐了大概有5个小时。</p><p>依然在做张三的问题现在把问题贴出来吧</p><p></br>&emsp;&emsp;</p><pre><code>/*张三一个月生活费800如果他的钱花到少于200就去搬砖搬砖一天+100记录张三这个月的支出和收入   1.程序可以一直运行，除非收到退出指令   2.当余额少于200的时候，输出3句去搬砖的提示   解决方法：        1.成员变量            1.1 张三初始化的钱数量，张三的天数        2.成员方法            2.1 张三每天花钱            2.2 张三每天搬砖能 +100            2.3 程序是一直运行的，除非接收到退出指令            2.4 余额少于200时，输出3句去搬砖的提示 */</code></pre><p></br>&emsp;&emsp;</p><p>已完善：</p><pre><code class="hljs javascript">public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;  int day = <span class="hljs-number">0</span>;  int money = <span class="hljs-number">800</span>;  int exp = <span class="hljs-number">0</span>;      <span class="hljs-comment">//总支出</span>  int income = <span class="hljs-number">0</span>;     <span class="hljs-comment">//总收入</span>  <span class="hljs-built_in">String</span> work = <span class="hljs-literal">null</span>;  Scanner input = <span class="hljs-keyword">new</span> Scanner(System.in);  Random r = <span class="hljs-keyword">new</span> Random();  <span class="hljs-keyword">do</span> &#123;      System.out.println(<span class="hljs-string">&quot;请输入：消费、打工、退出&quot;</span>);      work = input.next();      <span class="hljs-keyword">if</span> (work.equals(<span class="hljs-string">&quot;打工&quot;</span>)) &#123;          money += <span class="hljs-number">100</span>;           <span class="hljs-comment">//打工+100</span>          int im = money;         <span class="hljs-comment">//这次打工的收入</span>          income = im;            <span class="hljs-comment">//把这次的钱传给总收入</span>          int f1 = money;          System.out.println(<span class="hljs-string">&quot;您打工挣得&quot;</span> + f1);          System.out.println(<span class="hljs-string">&quot;您总资产现为：&quot;</span> + money);      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (work.equals(<span class="hljs-string">&quot;消费&quot;</span>)) &#123;          <span class="hljs-keyword">if</span> (money &gt;= <span class="hljs-number">200</span>) &#123;              int iq = <span class="hljs-number">0</span>;              int consumption = r.nextInt(<span class="hljs-number">801</span>);              money -= consumption;        <span class="hljs-comment">//随机消费</span>              iq = consumption;           <span class="hljs-comment">//这次消费的钱传给一个储存变量</span>              exp = iq;                   <span class="hljs-comment">//把这次的钱传给总支出</span>              System.out.println(<span class="hljs-string">&quot;这次消费了：&quot;</span> + consumption);              System.out.println(<span class="hljs-string">&quot;您总资产现为：&quot;</span> + money);          &#125;<span class="hljs-keyword">else</span> &#123;              System.out.println(<span class="hljs-string">&quot;您的余额已不足200元，总资产为：&quot;</span> + money);              System.out.println(<span class="hljs-string">&quot;打工去吧&quot;</span>);              System.out.println(<span class="hljs-string">&quot;打工去吧&quot;</span>);              System.out.println(<span class="hljs-string">&quot;打工去吧&quot;</span>);          &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (work.equals(<span class="hljs-string">&quot;退出&quot;</span>)) &#123;          System.out.println(<span class="hljs-string">&quot;程序已经退出！&quot;</span>);          System.exit(<span class="hljs-number">0</span>);     <span class="hljs-comment">//程序退出</span>          input.close();          <span class="hljs-comment">//结束输入</span>      &#125;           <span class="hljs-keyword">if</span> (day &lt; <span class="hljs-number">30</span>)&#123;          day += <span class="hljs-number">1</span>;          System.out.println(<span class="hljs-string">&quot;今天是第：&quot;</span>+day+<span class="hljs-string">&quot;天&quot;</span>);      &#125;<span class="hljs-keyword">else</span> &#123;          day = <span class="hljs-number">0</span>;          System.out.println(<span class="hljs-string">&quot;月底了，这个月总支出：&quot;</span>+ exp);          exp = <span class="hljs-number">0</span>;          System.out.println(<span class="hljs-string">&quot;总收入为：&quot;</span>+ income);          income = <span class="hljs-number">0</span>;      &#125;  &#125;<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);  &#125;</code></pre><hr><p> <del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于今天2020.11.16</title>
    <link href="/2020/11/16/%E5%85%B3%E4%BA%8E%E4%BB%8A%E5%A4%A92020-11-16/"/>
    <url>/2020/11/16/%E5%85%B3%E4%BA%8E%E4%BB%8A%E5%A4%A92020-11-16/</url>
    
    <content type="html"><![CDATA[<h2 id="今日日程报告"><a href="#今日日程报告" class="headerlink" title="今日日程报告"></a>今日日程报告</h2><p></br>&emsp;&emsp;<br>今天在刷题，这个题我刷了半天，现在还在找解决思路，感觉是自己的懒，不愿意动脑子，老师也不回我，感觉很烦，主要原因应该是我自己懒，写一下代码又去吹吹牛逼。<br></br>&emsp;&emsp;<br>今天的问题所在就是我懒，爱吹牛。<br></br>&emsp;&emsp;<br>感觉自己写写还是可以写出来的<br></br>&emsp;&emsp;<br>这个明天问问老师先</p><p></br>&emsp;&emsp;<br>总结：<br></br>&emsp;&emsp;&emsp;&emsp;<br>今天啥都没学到<br></br>&emsp;&emsp;&emsp;&emsp;<br>真是个废物</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Scanner的进阶使用</title>
    <link href="/2020/11/15/Scanner%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/15/Scanner%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Scanner的进阶使用"><a href="#Scanner的进阶使用" class="headerlink" title="Scanner的进阶使用"></a>Scanner的进阶使用</h2><hr><p>Scanner类的功能，可以实现键盘输入数据，到程序当中。</p><p>Scanner属于引用数据类型</p><p>引用类型的一般使用步骤：</p><p>1.导包<br></br>&emsp;&emsp;<br>improt 包路径.类名称；<br></br>&emsp;&emsp;<br>如果需要使用目标类，和当前类位于同一个包下，则可以省略导报语句不写。<br></br>&emsp;&emsp;<br>只有java.Lang包下的内容不需要导包，其他的包都需要improt语句。</p><p>2.创建<br></br>&emsp;&emsp;<br>类名称 对象名 = new 类名称();</p><p>3.使用<br></br>&emsp;&emsp;<br>对象名.成员方法名()<br></br>&emsp;&emsp;<br>获取键盘输入的一个int数字： int num = sc.nextInt();<br></br>&emsp;&emsp;<br>获取键盘输入的一个字符串：String str = sc.next();</p><hr><p>今天很累很累，感觉自己像是个废物，学了这么多，做个题就卡壳了，要一步一步脚踏实地<br></br></br><br>知识学习就停留在这把，明天更新小练习<br></br></br><br>明天继续刷题巩固</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>完整方法的构造</title>
    <link href="/2020/11/14/%E5%AE%8C%E6%95%B4%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0/"/>
    <url>/2020/11/14/%E5%AE%8C%E6%95%B4%E6%96%B9%E6%B3%95%E7%9A%84%E6%9E%84%E9%80%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="完整的方法构造"><a href="#完整的方法构造" class="headerlink" title="完整的方法构造"></a>完整的方法构造</h2><p>构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。</p><p>格式：<br>public 类名称(参数类型 参数名称){<br>    方法体<br>}<br>注意事项：<br></br>&emsp;&emsp;&emsp;&emsp;<br>1.构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样<br></br>&emsp;&emsp;&emsp;&emsp;<br>2.构造方法不要写返回值，连void都不写<br></br>&emsp;&emsp;&emsp;&emsp;<br>3.构造方法不能return一个具体返回值<br></br>&emsp;&emsp;&emsp;&emsp;<br>4.如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数，方法体什么事情都不做。<br></br>&emsp;&emsp;&emsp;&emsp;<br>5.一旦编写了至少一个构造方法，那么编译器将不再赠送。<br></br>&emsp;&emsp;&emsp;&emsp;</p><hr><p>Demo1代码：</p><pre><code class="hljs javascript"><span class="hljs-comment">//组成部分：成员变量</span>private <span class="hljs-built_in">String</span> name;private int age;<span class="hljs-comment">//成员方法</span>public <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"></span>)</span>&#123;       <span class="hljs-comment">//无参构造方法</span>    System.out.println(<span class="hljs-string">&quot;无参构造方法执行啦！&quot;</span>);&#125;public <span class="hljs-function"><span class="hljs-title">Student</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name,int age</span>)</span>&#123;        <span class="hljs-comment">//全参构造方法（全部参数都用了）</span>    System.out.println(<span class="hljs-string">&quot;全参构造方法执行啦！&quot;</span>);    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;&#125;<span class="hljs-comment">//Getter Setter</span>public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.name = name;&#125;public <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> name;&#125;public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">setAge</span>(<span class="hljs-params">int age</span>)</span>&#123;    <span class="hljs-built_in">this</span>.age = age;&#125;public int <span class="hljs-function"><span class="hljs-title">getAge</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> age;&#125;</code></pre><p>Dome2执行代码：</p><pre><code class="hljs javascript">public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;        Student stu1 = <span class="hljs-keyword">new</span> Student(); <span class="hljs-comment">//无参构造</span>        System.out.println(<span class="hljs-string">&quot;========================&quot;</span>);        Student stu2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;赵丽颖&quot;</span>,<span class="hljs-number">20</span>); <span class="hljs-comment">//全参构造</span>        <span class="hljs-comment">//如果需要改变对象当中的成员变量数据内容，仍然还需要使用setXxx方法</span>        System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span>+stu2.getName()+<span class="hljs-string">&quot;,年龄：&quot;</span>+stu2.getAge());        stu2.setAge(<span class="hljs-number">21</span>);<span class="hljs-comment">//改变年龄</span>        System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span>+stu2.getName()+<span class="hljs-string">&quot;,年龄：&quot;</span>+stu2.getAge());            &#125;</code></pre><p>   </br>&emsp;&emsp;<br>   所以这种重载形式的全参数的构造方法，<br>   </br>&emsp;&emsp;<br>   只是在创建对象的时候更加方便我们把那些现成的数据通过参数的形式设置进来，<br>   </br>&emsp;&emsp;<br>   而省去你多次调用set什么的方法这样的麻烦<br>   </br>&emsp;&emsp;<br>   </br>&emsp;&emsp;但是在当你修改对象内容的时候set方法还是有用的</p><hr><p>昨天写的笔记忘记保存了，哈哈，脑子太笨了，今晚12：12才更新好<br>   </br><br>   下次尽量早点更代码，还有，我博客写的很乱，下次有时间就摆好，七牛云也没时间弄，真是醉了，还好最近不上传图片记录</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>this的使用</title>
    <link href="/2020/11/13/this%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/11/13/this%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Java之this的使用"><a href="#Java之this的使用" class="headerlink" title="Java之this的使用"></a>Java之this的使用</h2><hr><p>当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。<br></br><br>如果需要访问本类当中的成员变量，需要使用格式：        &emsp;&emsp;类似两个name不知道用谁的，但是加了this程序就知道了<br></br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;    this.成员变量名<br></br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;说白了就是指向性的对应内存区的使用。<br></br>&emsp;&emsp;<br></br>&emsp;&emsp;“通过谁调用的方法，谁就是this”</p><hr><p>例：</p><pre><code class="hljs javascript">D1：<span class="hljs-built_in">String</span> name;<span class="hljs-comment">//参数name是对方的名字</span><span class="hljs-comment">//成员变量name是自己的名字</span>public <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">sayHello</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span>&#123;Systeml.out.println(name+<span class="hljs-string">&quot;,你好，我是&quot;</span>+<span class="hljs-built_in">this</span>.name);&#125;D2：Person person = <span class="hljs-keyword">new</span> Person();person.name = <span class="hljs-string">&quot;王健林&quot;</span>;person.sayHello(name:<span class="hljs-string">&quot;王思聪&quot;</span>);</code></pre><hr><p>写在后面：<br></br>&emsp;&emsp;<br>    由于最近事情比较多，要跑步，要洗衣服，要洗鞋子，要吃饭，要上课，要预习，我这并不是为自己找借口，我没找到一个时间都会不停的学习，不停的敲代码，虽然很累但是生活很充实，这破电脑又要没电了，真是醉了，但生活还得继续呀！！！！！！！！！！！！！！！！！！！！！！！！加油！！！！！！<br>    </br>&emsp;&emsp;<br>    还有就是Github的服务器是真的慢，如果有时间一定要找个树莓派来做服务器，但是网线怎么办，还得思考思考。<br>     </br>&emsp;&emsp;<br>     其实我写了很多笔记，但是更新为什么这么慢，因为我在挤牙膏呀！！！！<br>      </br>&emsp;&emsp;<br>      又到了11点，告辞！最后再弱弱说一句，我的博客好垃圾呀，没有别人的炫酷，如果有时间我一定会帮你加上几个功能！！！！！！</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>类与方法</title>
    <link href="/2020/11/11/%E7%B1%BB%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <url>/2020/11/11/%E7%B1%BB%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="类与方法"><a href="#类与方法" class="headerlink" title="类与方法"></a>类与方法</h2><hr><p>脑子不太好的我容易被混淆了呀<br></br>&emsp;&emsp;我们先来看看类的定义格式：</p><pre><code>public class ClassName&#123;    //成员变量    //成员方法    &#125;</code></pre><p></br>&emsp;&emsp;再来看看方法的定义格式：</p><pre><code>    public static void 方法名称 ( )&#123;    方法体    &#125;</code></pre><p>难道就没有感觉有那么一丢丢像嘛<br></br>不过把代码摆出来就清晰了许多<br></br>以上是我初学的问题所述<br></br>这时候我们来理解一下类和方法<br></br>&emsp;&emsp;</p><hr><h3 id="运用类比来解释类和方法"><a href="#运用类比来解释类和方法" class="headerlink" title="运用类比来解释类和方法"></a>运用类比来解释类和方法</h3><p>事物与类的对比<br></br>现实世界的一类事物：<br>    </br>&emsp;&emsp;属性：事物的状态信息。<br>    </br>&emsp;&emsp;行为：事物能够做什么。<br></br>Java中class描述事物也是如此：<br>    </br>&emsp;&emsp;成员变量：对应事物的属性<br>    </br>&emsp;&emsp;成员方法：对应事物的行为</p><p></br>&emsp;&emsp;运用类比（类比不管在生活，写代码，还是学习上，都是一个很重要的概念）的方法我们可以把类看作是“一个人类”<br></br>&emsp;&emsp;人类有属性（变量）（我的血量，我的蓝量，我的名字，我的身高，我的体重，这些都可以看作是我的属性）<br></br>&emsp;&emsp;人类的行为（方法）（我吃饭，我睡觉，我敲代码，我打游戏这些都是我的行为）</p><p></br></br></br></br>今天就先到这吧，破电脑没电了，学校的屁事还有点多<br></br>最后一定是自律自律自律！！！！加油你能行</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以细行律身，不可以细行取人。</title>
    <link href="/2020/11/10/%E4%BB%A5%E7%BB%86%E8%A1%8C%E5%BE%8B%E8%BA%AB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%BB%86%E8%A1%8C%E5%8F%96%E4%BA%BA%E3%80%82/"/>
    <url>/2020/11/10/%E4%BB%A5%E7%BB%86%E8%A1%8C%E5%BE%8B%E8%BA%AB%EF%BC%8C%E4%B8%8D%E5%8F%AF%E4%BB%A5%E7%BB%86%E8%A1%8C%E5%8F%96%E4%BA%BA%E3%80%82/</url>
    
    <content type="html"><![CDATA[<h2 id="第一次为今天的-“混”-想一个标题"><a href="#第一次为今天的-“混”-想一个标题" class="headerlink" title="第一次为今天的 “混” 想一个标题"></a>第一次为今天的 “混” 想一个标题</h2><h5 id="那就是魏源的这首诗句：以细行律身，不可以细行取人。"><a href="#那就是魏源的这首诗句：以细行律身，不可以细行取人。" class="headerlink" title="那就是魏源的这首诗句：以细行律身，不可以细行取人。"></a>那就是魏源的这首诗句：以细行律身，不可以细行取人。</h5><hr><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;《默觚下·治篇》清代思想家魏源</p><p>原文：以细行律身，不可以细行取人。</p><p>译文：君子要从一点一滴细微之处严格要求自己，却不会紧扣别人行为中的瑕疵不放手。<br></br><br></br></br></br></br><br></br><br>&emsp;&emsp;由于刚刚创建的博客，对于很多东西都不了解，但是一直都在学习当中，愿自己努力加油！<br></br><br></br>今天遇到了Hexo-admin的一个问题，就是在上传图片的时候在本地可以显示，但是上传到github就不能显示了，很奇怪，我也不做过多的深究了，我的七牛云还在审核当中，估计明天就能使用图床没那么麻烦了。</p><p></br>&emsp;&emsp;今天还在补数学补英语，加油呀宝贝er</p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法之 Text</title>
    <link href="/2020/11/09/%E5%86%99%E5%9C%A82020-11-9/"/>
    <url>/2020/11/09/%E5%86%99%E5%9C%A82020-11-9/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法之-Text"><a href="#Markdown语法之-Text" class="headerlink" title="Markdown语法之 Text"></a>Markdown语法之 Text</h1><hr><h2 id="Headers-标题"><a href="#Headers-标题" class="headerlink" title="Headers            //标题"></a>Headers            //标题</h2><hr><h1 id="This-is-an-tag"><a href="#This-is-an-tag" class="headerlink" title="This is an  tag"></a>This is an <h1> tag</h1><h2 id="This-is-an-tag-1"><a href="#This-is-an-tag-1" class="headerlink" title="This is an  tag"></a>This is an <h2> tag</h2><h6 id="This-is-an-tag-2"><a href="#This-is-an-tag-2" class="headerlink" title="This is an  tag"></a>This is an <h6> tag</h6><p>语法区：</p><p><img src="%5Cimages%5Cpasted-8.png" alt="upload successful"></p><hr><h2 id="Examples-示例"><a href="#Examples-示例" class="headerlink" title="Examples            //示例"></a>Examples            //示例</h2><hr><p>It’s very easy to make some words <strong>bold</strong> and other words <em>italic</em> with Markdown. You can even <a href="http://google.com/">link to Google!</a></p><p>语法区：</p><p><img src="%5Cimages%5Cpasted-9.png" alt="upload successful"></p><hr><h2 id="Emphasis-强调"><a href="#Emphasis-强调" class="headerlink" title="Emphasis            //强调"></a>Emphasis            //强调</h2><hr><p><em>This text will be italic</em><br><em>This will also be italic</em></p><p><strong>This text will be bold</strong><br><strong>This will also be bold</strong></p><p><em>You <strong>can</strong> combine them</em></p><p>语法区：</p><p><img src="%5Cimages%5Cpasted-10.png" alt="upload successful"></p><hr><h2 id="Ordered-命令"><a href="#Ordered-命令" class="headerlink" title="Ordered        //命令"></a>Ordered        //命令</h2><hr><ul><li>Item 1</li><li>Item 2<ul><li>Item 2a</li><li>Item 2b</li></ul></li></ul><p>语法区：</p><p><img src="%5Cimages%5Cpasted-12.png" alt="upload successful"></p><hr><h2 id="Images-图像"><a href="#Images-图像" class="headerlink" title="Images        //图像"></a>Images        //图像</h2><hr><p><img src="/images/logo.png" alt="GitHub Logo"><br>Format: <img src="url" alt="Alt Text"></p><p>语法区：</p><p><img src="%5Cimages%5Cpasted-11.png" alt="upload successful"></p><hr><h2 id="Links-链接"><a href="#Links-链接" class="headerlink" title="Links        //链接"></a>Links        //链接</h2><hr><p><a href="http://github.com/">http://github.com</a> - automatic!<br><a href="http://github.com/">GitHub</a></p><p>语法区：</p><p><img src="%5Cimages%5Cpasted-13.png" alt="upload successful"></p><hr><h2 id="Blockquotes-块"><a href="#Blockquotes-块" class="headerlink" title="Blockquotes    //块"></a>Blockquotes    //块</h2><hr><p>As Kanye West said:</p><blockquote><p>We’re living the future so<br>the present is our past.            </p></blockquote><p>语法区：</p><p><img src="%5Cimages%5Cpasted-14.png" alt="upload successful"></p><hr><h2 id="Inline-code-内联代码"><a href="#Inline-code-内联代码" class="headerlink" title="Inline code    //内联代码"></a>Inline code    //内联代码</h2><hr><p>I think you should use an<br><code>&lt;addr&gt;</code> element here instead.</p><p>图片区：</p><p><img src="%5Cimages%5Cpasted-4.png" alt="upload successful"></p><hr><h2 id="Github风格的高亮"><a href="#Github风格的高亮" class="headerlink" title="Github风格的高亮"></a>Github风格的高亮</h2><hr><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fancyAlert</span>(<span class="hljs-params">arg</span>) </span>&#123;  <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">arg</span>)</span> &#123;    $.facebox(&#123;<span class="hljs-attr">div</span>:<span class="hljs-string">&#x27;#foo&#x27;</span>&#125;)  &#125;&#125;</code></pre><p>语法区：</p><p><img src="%5Cimages%5Cpasted-5.png" alt="upload successful"></p><hr><h2 id="Task-Lists-任务列表"><a href="#Task-Lists-任务列表" class="headerlink" title="Task Lists    //任务列表"></a>Task Lists    //任务列表</h2><hr><ul><li><input checked="" disabled="" type="checkbox"> @mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</li><li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported)</li><li><input checked="" disabled="" type="checkbox"> this is a complete item</li><li><input disabled="" type="checkbox"> this is an incomplete item</li></ul><p>语法区：<br><img src="%5Cimages%5Cpasted-6.png" alt="upload successful"></p><hr><h2 id="Tables-数据表"><a href="#Tables-数据表" class="headerlink" title="Tables        //数据表"></a>Tables        //数据表</h2><hr><p>You can create tables by assembling a list of words and dividing them with hyphens - (for the first row), and then separating each column with a pipe |:</p><p>您可以通过组合单词列表并用连字符分隔（对于第一行），然后用管道分隔每个列来创建表：</p><p>-</p><table><thead><tr><th>First Header</th><th>Second Header</th></tr></thead><tbody><tr><td>Content from cell 1</td><td>Content from cell 2</td></tr><tr><td>Content in the first column</td><td>Content in the second column</td></tr></tbody></table><p>语法区：</p><p><img src="%5Cimages%5Cpasted-7.png" alt="upload successful"></p><hr><p>文章引用：<a href="https://guides.github.com/features/mastering-markdown/">https://guides.github.com/features/mastering-markdown/</a></p><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    <categories>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java命名规范</title>
    <link href="/2020/11/09/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>/2020/11/09/Java%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>一、命名规范</p><p>1、 项目名全部小写</p><p>2、 包名全部小写</p><p>3、 类名首字母大写，如果类名由多个单词组成，每个单词的首字母都要大写。</p><p>如：public class MyFirstClass{}</p><p>4、 变量名、方法名首字母小写，如果名称由多个单词组成，每个单词的首字母都要大写。</p><p>如：int index=0;</p><pre><code>   public void toString()&#123;&#125;</code></pre><p>5、 常量名全部大写</p><p>如：public static final String GAME_COLOR=”RED”;</p><p>6、所有命名规则必须遵循以下规则：</p><p>1)、名称只能由字母、数字、下划线、$符号组成</p><p>2)、不能以数字开头</p><p>3)、名称不能使用JAVA中的关键字。</p><p>4)、坚决不允许出现中文及拼音命名。</p><hr><p>二、注释规范</p><p>1、   类注释</p><p>在每个类前面必须加上类注释，注释模板如下：</p><p>/**</p><ul><li><p>Copyright (C), 2006-2010, ChengDu Lovo info. Co., Ltd.</p></li><li><p>FileName: Test.java</p></li><li><p>类的详细说明</p></li></ul><p>*</p><ul><li><p>@author 类创建者姓名</p><ul><li>@Date    创建日期</li></ul></li><li><p>@version 1.00</p></li></ul><p>*/</p><p>2、   属性注释</p><p>在每个属性前面必须加上属性注释，注释模板如下：</p><p>/** 提示信息 */</p><p>private String strMsg = null;</p><p>3、   方法注释</p><p>在每个方法前面必须加上方法注释，注释模板如下：</p><p>/**</p><ul><li>类方法的详细使用说明</li></ul><p>*</p><ul><li><p>@param 参数1 参数1的使用说明</p></li><li><p>@return 返回结果的说明</p></li><li><p>@throws 异常类型.错误代码 注明从此类方法中抛出异常的说明</p></li></ul><p>*/</p><p>4、   构造方法注释</p><p>在每个构造方法前面必须加上注释，注释模板如下：</p><p>/**</p><ul><li>构造方法的详细使用说明</li></ul><p>*</p><ul><li><p>@param 参数1 参数1的使用说明</p></li><li><p>@throws 异常类型.错误代码 注明从此类方法中抛出异常的说明</p></li></ul><p>*/</p><p>5、   方法内部注释</p><p>在方法内部使用单行或者多行注释，该注释根据实际情况添加。</p><p>如：//背景颜色</p><pre><code>   Color bgColor = Color.RED</code></pre><hr><p> 文章引用：<a href="https://www.cnblogs.com/maowang1991/archive/2013/06/29/3162366.html">https://www.cnblogs.com/maowang1991/archive/2013/06/29/3162366.html</a></p><hr><p><del>我正在黑暗中摸索前行，每一盏我点亮的路灯下都有我沾满泥垢的掌印，但光亮终会散满我所幻想的世界。</del></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
